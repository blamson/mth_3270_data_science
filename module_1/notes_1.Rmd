---
title: "MTH 3270 Exercises I"
author: "Brady Lamson"
date: "1/22/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#'%>%' <- magrittr::'%>%' 
library(dplyr)
```

# 3: Getting Started with R
## 3.1: Arithmetic Operators

- Below is a list of mathematical operators ordered from highest to lowest precedence:

| Operator | Function |
|---|---|
| ^ | Exponentiation |
| - | Unary minus sign |
| %% | Modulo |
| %/% | Integer Division |
| * / | Multiplication, Division |
| + - | Addition, Subtraction |

### Exercise 1:
Guess what the result of each of the following will be, then check your answers.

a) $4 + 2 * 8$
    - I would guess **20**. $2*8 = 16$ and $16 + 4 = 20$ \vspace{12pt}
    
b) $4 + 2 * 8 + 3$
    - I would guess **23**. $8 * 2$ would go first, and then 3 and 4 would be added afterward. \vspace{12pt}

c) $-2^2$
    - This one trips me up on TI calculators all the time. The exponential goes first, so we'll get a **-4** here. **Always** use paranthesis with exponentials. \vspace{12pt}

d) $1 + 2^2 * 4$
    - This is **17**. $2^2$ goes first, multiply that by 4 and then add 1. \vspace{12pt}

e) $(2 + 4) / 3 / 2$
    - This is **1**. The division by 3 wants to go first, but it can't. The numbers in the paranthesis have to be resolved so division can happen. We get $6 / 3 = 2$ and $2 / 2 = 1$. \vspace{12pt}

```{r, include=TRUE}
# Tests
result_3.1 <- c(
    4 + 2 * 8, 
    4 + 2 * 8 + 3,
    -2^2,
    1 + 2^2 * 4,
    (2 + 4) / 3 / 2
    )

data.table::data.table(
    "exercise" = LETTERS[1:5],
    "result" = result_3.1
    ) %>%
    glue::glue_data("The output of exercise {exercise} is {result}")
```

***
\pagebreak
## 3.2: Special Characters, Special Values, Etc.

- R ignores white space.
    - This means you can carry out commands across multiple lines! This is very useful for readability. 
    
- Sometimes you'll have to deal with special values. Two of these are:
    - Inf (Infinity)
    - Nan (Not a number)

- Any positive number divided by 0 will result in **Inf**. 0 divded by 0 results in **NaN**. 

### Exercise 2:
Guess what the result of each of the following will be, then check your answers.

a) $5 / 0$
     - My guess would be **Inf** based on the note above. \vspace{12pt}
     
b) $1 / \; \text{Inf}$
    - My guess would be **0**. It makes sense to my brain that 1 divded by an arbitrarily large number would approach 0, so we'll go with that! \vspace{12pt}
    
c) $0 / 0$
    - My guess would be **NaN** based on the note above. \vspace{12pt}
    
d) $\text{Inf} + 1$
    - This will just be **Inf**. \vspace{12pt}
    
```{r}
# Tests
result_3.2 <- c(
    5 / 0,
    1 / Inf,
    0 / 0,
    Inf + 1
)

data.table::data.table(
    "exercise" = LETTERS[1:4],
    "result" = result_3.2
    ) %>%
    glue::glue_data("The output of exercise {exercise} is {result}")
```

***
\pagebreak
## 3.3: Variables and the Assignment Operator

- Atomic Values
    - Numeric
        - Double (Double-precision floating-point, can store integer and non-integer decimals)
        - Integer
    - Character
    - Logical
    - Complex
    - Raw

Another type of variable is NULL, this represents an "empty" variable.

### Exercise 3:
What type of variable is created in each of the following commands? Check your answers by typing typeof(x):

a) x <- 45
    - This is an integer.
 
b) x <- "foo"
    - This is a character
    
c) x <- FALSE
    - This is a logical
    
d) x <- NULL
    - This is a NULL
    
```{r}
# Tests

x <- 45
typeof(x)

x <- "foo"
typeof(x)

x <- FALSE
typeof(x)

x <- NULL
typeof(x)
```

### Exercise 4:
Guess the final value of x in the following sequence of commands. Then check your answer.

```{r}
x <- 2
x <- x * 2 + 1
x <- x * 3
# My prediction is that x will be 15. 
x
```

### Exercise 5:
Write commands that do the following (in order):

```{r}
# 1: Create a variable y containing the value 5.
y <- 5

# 2: Overwrite the value of y by the value 3 * y
y <- 3 * y

# 3: Copy the value y into a new variable z
z <- y

```

***
\pagebreak
## 3.4: Introduction to Functions
### Exercise 6:
Look at the help page for sqrt() by typing:

? sqrt

Besides sqrt(), what other R function is described on the help page?
    - abs() and sqrt() are both described. 
    
### Exercise 7:
Look at the help page for signif() by typing:

? signif

From the help page, how many arguments does signif() have?
    - It has two arguments, **x** and **digits**. 
    
### Exercise 8:
Look at the arguments for signif(). This function prints the value passed for x to the number of significant digits specified by digits. 
a) From the help page, what is the default value for the digits argument?
    - 6
b) To how many significant digits will the value 342.88937 be printed using the default value for the digits argument?
    - It will be to 6 significant digits as a digits value is not specified. That would probably be **342.889**.
    
### Exercise 9:
a) Write a command using *named argument matching* that prints the value 342.88937 to 5 significant digits.
b) Write a command using *positional matching* that prints the value 342.88937 to 5 significant digits.

```{r}
signif(digits = 5, x = 342.88937)
signif(342.88937, 5)
```

***
\pagebreak
## 3.5: The R Workspace
### Exercise 10:
Create a few variables named x, y and z. Then type the following sequence of commands, paying attention to the output from ls() each time:

```{r}
x = 1
y = 'a'
z = NaN

ls()
rm(x)
ls()
rm(list = ls())
ls()
```
The three calls to ls() return everything in the current workspace. So, in that case, it's the pipe I took from magrittr, my previous result lists and the 3 different variables I had just made. The rm() removes the x so that isn't present in the next ls() and then the next rm() removes everything in the current workspace. Because of that, the final ls() simply returns character(0) as nothing is in the workspace. It is an empty list. 

***
\pagebreak
## 3.6: A Preview of R Data Structures

- **Vectors** can store any of the *atomic* types
- **Matrices** are like two-dimensional vectors. 
- One limitation of vectors is that everything in them must be the same type. Another type of container, called a **list** does not have that limitation. 
    - Lists can contain anything. For example they can contain vectors and even other lists. They're very versatile. 
- **Data Frames** are like matrices but can have a mix of *categorical* and *quantitative* data types.
    - It is of note that each *column* of a data frame is a *vector*. 
- An **array** is like a matrix but it can have more than two dimensions (e.g. rows, columns, and layers).

### Exercise 11:
Write a command using c() that creates a vector containing the values: (3,7,2,8)
```{r}
c(3, 7, 2, 8)
```

***
\pagebreak
### Exercise 12:
Write a command using matrix() that creates the following matrix:
```{r}
matrix(
    data = seq(from = 2, to = 8, by = 2), nrow = 2, ncol = 2
    )
```

### Exercise 13: 
Write a command using list() that creates a list containing the following elements: ("e", 9, TRUE)
```{r}
list("e", 9, TRUE)
```

### Exercise 14:
Write a command using data.frame that creates a data frame containing the following data set:

| Category | Value |
|---|---|
| A | 5 |
| A | 4 |
| B | 6 |
| B | 6 |
| C | 9 |
| C | 8 |

```{r}
data.frame(
    "Category" = sort(rep(LETTERS[1:3], 2)),
    "Value" = c(5, 4, 6, 6, 9, 8)
)
```


# 4: Vectors
## 4.2: Vector Arithmetric and Recycling
### Exercise 15: 
Guess the result of the following code.

This code snippet will simply combine the two vectors resulting in a single vector of 2:9.
```{r}
x <- c(2, 3, 4, 5)
y <- c(6, 7, 8, 9)
c(x, y)
```

This code snippet will result in a vector of (8, 10, 12, 14).
```{r}
x + y
```

### Exercise 16: 
Guess the result of the following code.

This code snippet will add 1 to the vector x, giving (3, 4, 5, 6)
```{r}
x <- c(2, 3, 4, 5)
x + 1
```

This code snippet will multiply all values in the vector by 2, giving (4, 6, 8, 10)
```{r}
x * 2
```

### Exercise 17:
Guess the result of the following code.

This code snippet will utilize some recycling. You'll get $6+2$, $7+3$ and, due to recycling, $8+2$. As a result we'll get (8, 10, 10)
```{r}
y <- c(6, 7, 8)
z <- c(2, 3)
y + z
```

### Exericse 18:
Guess the result of the following code.

Both is.vector() functions will return TRUE. That's due to single-valued variables and constants being vectors of length 1, and also the fact that both $a$ and $b$ here are equivalent operations.

```{r}
# a
x <- 2
is.vector(x)

# b
is.vector(2)
```

***
\pagebreak
## 4.3: Vector Coercion
- All elements of a vector must be the same type, so if you try to combine vectors of different types, they'll be ***coerced*** to the most *flexible* type. Types from least to most flexible are:

| Flexibility | Type |
|---|---|
| 1 (Least Flexible) | Logical |
| 2 | Integer |
| 3 | Double |
| 4 (Most Flexible) | Character |


### Exercise 19:
Guess the result of the following code.

a) The below code will result in a vector of ("2", "3", "a") due to integers being less flexible than characters.
```{r}
x <- c(2, 3, "a")
x
```

b) Logicals are the least flexible, so TRUE will be coerced into a 1. The result will be (2, 3, 1)
```{r}
x <- c(2, 3, TRUE)
x
```

c) Logicals are the least flexible so they'll be coerced to strings. The result will be ("a", "b", "FALSE", "TRUE")
```{r}
x <- c("a", "b")
y <- c(FALSE, TRUE)
c(x, y)
```

***
\pagebreak
## 4.4: Common Vector Operations
### Exercise 20:
Consider the following vector:
```{r}
x <- c(7, 6, 4, 2, 3, 5)
```

Guess the result of the following code. 

a) x[2]
    - This will be the second index, so **6**.
b) x[-2]
    - This will be all *but* the second index, so **(7, 4, 2, 3, 5)**
c) x[c(1, 2)]
    - This is the first and second index, so **(7, 6)**
d) x[c(2, 1)]
    - This is the second and first index, so **(6, 7)**
e) x[1] <- 5
    - This changes the first index, so x is now **(5, 6, 4, 2, 3, 5)**
    
```{r}
x[2]
x[-2]
x[c(1,2)]
x[c(2,1)]
```
```{r}
x[1] <- 5
x
```

### Exercise 21:
Consider the following vector:
```{r}
x <- c(7, 6, 4, 2, 3, 5)

# a) Write a command that returns the 4th element of x
x[4]

# b) Write a command that replaces the 4th element of x with the value 1
x[4] <- 1

# c) Write a command that returns all but the 6th element of x
x[-6]

```

### Exercise 22:
Guess the result of the following code:

```{r}
x <- c(7, 6, 4, 2)
ans <- x[c(2, 1, 3, 4)]
```

This code snippet is simply reordering the vector. What we get from this is **(6, 7, 4, 2)**

```{r}
ans
```

### Exercise 23:
Consider the following vector:
```{r}
x <- c(7, 6, 4, 2, 3, 5)

# a) Sort the vector in ascending order.
sort(x)

# b) Sort the vector in reverse order.
rev(x)

# c) Sort the vector in descending order.
sort(x, decreasing = TRUE)
```

### Exercise 24:
Consider the same vector as previous. Guess the result of the following code.
```{r}
ans <- x[c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE)]
```

This code snippet will return only the values with TRUE at their index. So we'll get **(4, 5)**.
```{r}
ans
```
### Exercise 25:
Guess the result of the following code:

a) 1:5
    - This will return a vector 1 through 5.
    
b) 6:10
    - This will return a vector 6 through 10.

c) 5:1
    - This will return a vector 5 through 1, descending.
    
```{r}
1:5
6:10
5:1
```

### Exercise 26:
Guess the result of the following code:

is.vector(1:5)
    - My guess would be this returning TRUE. 
    
```{r}
is.vector(1:5)
```

### Exercise 27:
Guess the result of the following code:

a) seq(from = 1, to = 2.5, by = 0.5)
    - (1, 1.5, 2, 2.5)
b) seq(from = 2.5, to = 1, by = -0.5)
    - (2.5, 2, 1.5, 1)
    
```{r}
seq(from = 1, to = 2.5, by = 0.5)
seq(from = 2.5, to = 1, by = -0.5)
```

### Exercise 28:
Guess the result of the following code:

a) rep(2, times = 3)
    - (2, 2, 2)

b) rep(1:2, times = 3)
    - (1, 2, 1, 2, 1, 2)

```{r}
rep(2, times = 3)
rep(1:2, times = 3)
```

***
\pagebreak
## 4.5: Comparison Operators
### Exercise 29:
Consider the following vector:
```{r}
x <- c(3, 4, 10)
```

Guess the result of the following code.
a) x == 4
    - (FALSE, TRUE, FALSE)
b) x > 4
    - (FALSE, FALSE, TRUE)
c) x >= 4
    - (FALSE, TRUE, TRUE)
d) x != 4
    - (TRUE, FALSE, TRUE)
    
```{r}
x == 4
x > 4
x >= 4
x != 4
```

### Exercise 30:
Consider the following two vectors:
```{r}
x <- c(3, 4, 10)
y <- c(3, 4, 5)
```

Guess the result of the following code:
a) x == y
    - (TRUE, TRUE, FALSE)
b) x != y
    - (FALSE, FALSE, TRUE)

```{r}
x == y
x != y
```

### Exercise 31:
Guess the result of the following code:
a) TRUE + TRUE + FALSE + FALSE + FALSE
    - 2
b) sum(c(TRUE, TRUE, FALSE, FALSE, FALSE))
    - 2
```{r}
TRUE + TRUE + FALSE + FALSE + FALSE
sum(c(TRUE, TRUE, FALSE, FALSE, FALSE))
```

### Exercise 32:
Consider the following vector:
```{r}
x <- c(10, 8, -2, -6, -5)
```

Guess the result of the following code:
a) x > 0
    - (TRUE, TRUE, FALSE, FALSE, FALSE)
b) sum(x > 0)
    - 2

```{r}
x > 0
sum(x > 0)
```


***
\pagebreak
## 4.6: Using any(), all(), and which(), which.min(), **and** which.max()
### Exercise 33:
Consider the vector
```{r}
x <- c(2,8,6,7,1,4,9)
```
Guess the result of the following code:
a) any(x == 4)
    - TRUE
b) all(x == 4)
    - FALSE
c) which(x == 4)
    - 6
d) which(x != 4)
    - (1, 2, 3, 4, 5, 7)

```{r}
# Tests
any(x == 4)
all(x == 4)
which(x == 4)
which(x != 4)
```

### Exercise 34:
Consider the following vectors:
```{r}
x <- c(53, 42, 64, 71, 84, 62, 95)
y <- c(53, 41, 68, 71, 81, 66, 65)
```
a) Write a command involving any() and == to determine if *any* of the values in x are equal to their corresponding value in y.
```{r}
any(x == y)
```
b) Write a command involving all() and == to determine if *all* of the values in x are equal to their corresponding value in y.
```{r}
all(x == y)
```
c) Write a command involving which() and == to determine *which* of the values in x are equal to their corresponding value in y.
```{r}
which(x == y)
```

### Exercise 35:
Consider the x vector from the previous problem. Guess the output of the following code:

a) which.min(x)
    - 42
b) which.max(x)
    - 95
```{r}
which.min(x)
which.max(x)
```

***
\pagebreak
## 4.7: Computing Summary Statistics
### Exercise 36: 
Consider the following data set:
```{r}
x <- c(10, 147, 7, 6, 7, 12, 9, 12, 11, 8)

# a) Use mean() to compute the mean
mean(x)

# b) Use median() to calculate the median
median(x)

# c) Use sd() to calculate the standard deviation
sd(x)
```

### Exercise 37: 
The standard deviation measures variation in a set of data.

a) What do you think the standard deviation of the following dataset will be? u <- c(5, 5, 5, 5, 5)
    - 0. All the values are the same so there is no variation.
```{r}
sd(c(5, 5, 5, 5, 5))
```
b) Which of the following two data sets do think will have a higher standard deviation?
    - The second one will have the higher standard deviation. The means of the two data sets are the same, but the second data set has values far further away from said mean.
```{r}
sd(c(5, 6, 7))
sd(c(1, 6, 11))
```

***
\pagebreak
## 4.8: Vectorized Computations
### Exercise 38:
The function abs() takes the absolute value of a number. Guess the result of the following command. 
    - (1, 3, 4, 2)
```{r}
abs(c(-1, 3, -4, -2))
```
### Exercise 39:
Consider the following temperature measurements, in degree Celsius:
```{r}
degreesC <- c(23, 19, 21, 22, 18, 20, 24, 25)
```
The relationship between Celsius ($^{\circ}C$) and Fahrenheit ($^{\circ}F$) is:
\[^{\circ}F = \frac{9}{5} \cdot ^{\circ}C + 32\]
Recall that arithmetic operators such as * and + are *vectorized*. Describe in words what the following command will do to the Celsius temperatures. Try it.
    - The following code will multiply each individual value by $\frac{9}{5}$ and then add 32 to them, thus converting each value in the vector from Celsius to Fahrenheit and assigning that to a new variable, degreesF. 
```{r}
degreesF <- (9/5) * degreesC + 32
degreesF
```

***
\pagebreak
## 4.9: Filtering
### Exercise 40:
Consider again the vector:
```{r}
x <- c(538, 432, 684, 716, 814, 624, 956)
```

Guess the result of the following code:
a) x[x > 700]
    - (716, 814, 956)
b) subset(x, subset = x > 700)
    - (716, 814, 956)
c) Write a command involving square brackets [ ] that extracts from x all values that are *not equal* to 814
```{r}
x[x > 700]
subset(x, subset = x > 700)

# c) 
subset(x, subset = x != 814)
```
\pagebreak

### Exercise 41: 
Consider this data set:

| Gender | Age | Blood Pressure |
|---|---|---|
| f | 33 | 118 |
| m | 35 | 115 |
| f | 29 | 110 |
| m | 34 | 117 |
| m | 37 | 112 |
| f | 36 | 119 |
| f | 35 | 114 |
| f | 40 | 121 |
| m | 43 | 123 |
| f | 38 | 117 |
| f | 40 | 120 |
| m | 44 | 121 |

```{r}
Gender <- c("f", "m", "f", "m", "m", "f", "f", "f", "m", "f", "f", "m")
Age <- c(33, 35, 29, 34, 37, 36, 35, 40, 43, 38, 40, 44)
BP <- c(118, 115, 110, 117, 112, 119, 114, 121, 123, 117, 120, 121)

ex_41_df <- data.table::data.table(
    "Gender" = Gender,
    "Age" = Age,
    "Blood Pressure" = BP
) %>% tibble::as_tibble()

ex_41_df
```

One of the commands below extracts the blood pressure of just the males, the other extracts the ages of those whose blood pressure exceeds 117. Which one is which?

a) Age[BP > 117]
    - This one extracts the ages of people with a blood pressure of more than 117.
b) BP[Gender == "m"]
    - This one extracts the blood pressure of the males in the data set.

***
\pagebreak
## 4.10: NA Values
### Exercise 42:
Guess the result of the following code:
a) 3 == NA
    - NA
b) NA == NA
    - NA
```{r}
3 == NA
NA == NA
```
### Exercise 43:
Consider the vector:
```{r}
x <- c(1, 2, NA)
```

Guess the result of the following code:
a) is.na(x)
    - FALSE FALSE TRUE
b) x[is.na(x)] <- 0
    - (1, 2, 0)

### Exercise 44:
Consider the same vector as in Exercise 43:

Guess the result of the following code: 
a) sum(x)
    - NA
b) sum(x, na.rm = TRUE)
    - 3
```{r}
sum(x)
sum(x, na.rm = TRUE)
```

***
\pagebreak
# 5: Matrices
## 5.1: Creating and Examining Matrices
### Exercise 45:
Here's a matrix x
```{r}
x <- c(8, 4) %>%
    rep(3) %>%
    sort(decreasing = TRUE) %>%
    matrix(nrow = 2, byrow = TRUE)
x
```
Guess the result of the following code:
a) dim(x)
    - 2, 3
b) nrow(x)
    - 2
c) ncol(x)
    - 3
```{r}
dim(x)
nrow(x)
ncol(x)
```
### Exercise 46:
What happens when you run the following command?
    - matrix(c(1,2,3), nrow = 4, ncol = 2)
    
My guess:
$$
\begin{bmatrix}
1 & 2 \\
2 & 3 \\
3 & 1 \\
1 & 2
\end{bmatrix}
$$
```{r}
matrix(c(1,2,3), nrow = 4, ncol = 2)
```

### Exercise 47: 
Consider the matrix:
$$
\begin{bmatrix}\
5 & 5 \\
4 & 4
\end{bmatrix}
$$

Do you think the following commands will produce the matrix above?
a) x <- matrix(c(5, 4, 5, 4), nrow = 2, ncol = 2)
    - Yes I do. Since it goes by column this should work just fine.
b) x <- cbind(c(5, 4), c(5, 4))
    - This will work as well. 
c) x <- rbind(c(5, 5), c(4, 4))
    - I think even this one works
    
```{r}
matrix(c(5, 4, 5, 4), nrow = 2, ncol = 2)
cbind(c(5, 4), c(5, 4))
rbind(c(5, 5), c(4, 4))
```

***
\pagebreak
## 5.2 General Matrix Operations
### Exercise 48: Consider the following matrix
```{r}
x <- matrix(1:9, nrow = 3, ncol = 3)
x
```

Guess the result of the following code:
a) x[1, 3]
    - 7
    
b) x[1, ]
    - 1, 4, 7
    
c) x[, 3]
    - 7, 8, 9
    
d) x[, -3]
    - My guess: $\big(\begin{smallmatrix}
1 & 4 \\
2 & 5 \\
3 & 6
\end{smallmatrix}\big)$
    
```{r}
# Tests

x[1, 3]
x[1,]
x[, 3]
x[, -3]
```

### Exercise 49:
Consider the following matrix:
```{r}
x <- matrix(1:6, nrow = 2, ncol = 3)
x
```
What does the following command do?
x[, c(3,1,2)]
    - This will return the 3rd column, the 1st column, followed by the 2nd column. It may look like: $\big(\begin{smallmatrix}
5 & 1 & 3 \\
6 & 2 & 4 \\
\end{smallmatrix}\big)$

```{r}
x[, c(3,1,2)]
```

\pagebreak
***
## 5.3: The apply() Function
### Exercise 50:
Consider the following matrix x:
```{r}
x <- matrix(
    c(8, 6, 3, 6, 5, 7),
    nrow = 3, ncol = 2
    )
x
```
Guess the result of the following code:
a) apply(x, MARGIN = 1, FUN = sum)
    - MARGIN 1 indicates the function will operate over the rows. Therefore, I would think we would get:
        - 14, 11, 10
b) apply(x, MARGIN = 2, FUN = min)
    - MARGIN 2 indicates we're operating over columns this time. So we'll get the minimum of each column.
        - 3, 5
```{r}
apply(x, MARGIN = 1, FUN = sum)
apply(x, MARGIN = 2, FUN = min)
```

